{
  "hash": "05e914d2641668a5ddedf5c6c023eee6",
  "result": {
    "markdown": "---\ntitle: 'Exploring OMPR with HiGHS solver'\nauthor: 'Notesofdabbler'\ndate: '2022-09-05'\nexecute: \n  eval: false\ncategories:\n  - R\n---\n\n\nThere is a class of software for modeling optimization problems referred to as algebraic modeling systems which provide a unified interface to formulate optimization problems in a manner that is close to mathematical depiction and have the ability to link to different types of solvers (sparing the user from solver specific ways of formulating the problem). Both commercial and open source options are available. [GAMS](https://www.gams.com/) and [AMPL](https://ampl.com/) are examples of commercial options. The popular open source options are [JuMP](https://jump.dev/JuMP.jl/stable/) in Julia and [Pyomo](http://www.pyomo.org/) in python. I have typically used Pyomo in Python but have [explored](https://notesofdabbler.github.io/R_pyomo/2020_07_01_r_pyomo_blogpost.html) using it from R. I recently became aware of algebraic modeling system in R provided by [OMPR](https://dirkschumacher.github.io/ompr/) package. \n\nThere are commercial and open-source options available for solvers also. For a class of optimization problems referred to as Mixed Integer Linear Programs (MILP), the commercial solvers such as [CPLEX](https://www.ibm.com/analytics/cplex-optimizer), and [GUROBI](https://www.gurobi.com/) perform significantly better than open source solvers such as [glpk](https://www.gnu.org/software/glpk/), and [CBC](https://github.com/coin-or/Cbc). A new open-source solver [HiGHS](https://highs.dev/) has been developed recently that has generated quite a bit of buzz and by different accounts looks like a promising option. There is now a [highs](https://cran.r-project.org/web/packages/highs/index.html) package in R that can call the HiGHS solver.\n\nIn this blog, I wanted to explore using OMPR modeling system with HiGHS solver by using it to solve a few examples of LP/MILP problems. \n\n### Example 1: Example from highs package\n\nHere I want to just describe the example in mathematical notation and show how OMPR model is close to mathematical notation. The full details of this example are in this [location](https://notesofdabbler.github.io/optwithR/highs_example_ompr.html).\n\n:::: {.columns}\n\n::: {.column width=\"40%\"}\n\n#### Example Problem in highs package\n\n$$\n\\begin{array}{ll}\n\\min & x_0 + x_1 + 3 \\\\\n& x_1 \\leq 7 \\\\\n& 5 \\leq x_0 + 2x_1 \\leq 15 \\\\\n& 6 \\leq 3x_0 + 2x_1 \\\\\n& 0 \\leq x_0 \\leq 4 \\\\\n& 1 \\leq x_1\n\\end{array}\n$$\n\n:::\n\n::: {.column width=\"60%\"}\n\n#### OMPR model\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nmdl = MIPModel() %>%\n      add_variable(x0, lb = 0, ub = 4, type = \"continuous\") %>%\n      add_variable(x1, lb = 1, type = \"continuous\") %>%\n      set_objective(x0+x1+3) %>%\n      add_constraint(x1 <= 7) %>%\n      add_constraint(x0 + 2*x1 <= 15) %>%\n      add_constraint(x0 + 2*x1 >= 5) %>%\n      add_constraint(3*x0 + 2*x1 >= 6)\n```\n:::\n\n\n:::\n::::\n\nOMPR integrates with [ROI](https://cran.r-project.org/web/packages/ROI/index.html) package to solve an optimization model since ROI package has several solver plugins. However, highs solver doesn't appear to have a ROI plugin yet. \n\nThe highs solver uses the following representation of the optimization problem:\n\n$$\n\\begin{array}{ll}\n\\min &Lx + x^tQx + offset \\\\\n&lhs \\leq Ax \\leq rhs \\\\\n&lower \\leq x \\leq upper \\\\\n&x \\in \\{integer, continuous\\}\n\\end{array}\n$$\n\n\nSo I [adapted](https://github.com/notesofdabbler/optwithR/blob/main/ompr_helperfns.R) the `as_ROI_model` function from package ompr.ROI to provide the information needed $(L, offset, A, lhs, rhs, lower, upper)$ and type of each $x$ variable for calling solver in highs package.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Convert ompr model to highs model\nhighs_mdl = as_highs_model(mdl)\n# solve highs model\ns <- highs_solve(L = as.numeric(highs_mdl$L), lower = highs_mdl$lower, upper = highs_mdl$upper,\n                 A = highs_mdl$A, lhs = highs_mdl$lhs, rhs = highs_mdl$rhs,\n                 offset = highs_mdl$offset)\ns[[\"status\"]]\ns[[\"objective_value\"]]\ns[[\"primal_solution\"]]\n```\n:::\n\nSolving the above problem results in an objective value of 5.75 and solution of (0.5, 2.25)\n\n### Example 2: Transportation Problem\n\nThis example discusses a transporation problem from [GAMS model library](https://www.gams.com/latest/gamslib_ml/libhtml/gamslib_trnsport.html) where the goal is to find the minimum cost way to meet market demand with available plant capacity. We just show how the OMPR package can handle variables involving indices using this example. The full description of this example is in this [location](https://notesofdabbler.github.io/optwithR/gms_trnsprt_ompr.html).\n\n::: {.panel-tabset}\n\n### Mathematical Formulation\n\n$$\n\\begin{array}{llr}\n\\min &\\sum_{p=1}^P\\sum_{m=1}^Mc_{pm}x_{pm} & (a) \\\\\n&\\sum_{m=1}^Mx_{pm} \\leq cap_p, \\;p=1,2,\\ldots,P  & (b)\\\\\n&\\sum_{p=1}^Px_{pm} \\geq dem_m, \\;m=1,2,\\ldots,M & (c) \\\\\n&x_{pm} \\geq 0, \\;p=1,2,\\ldots,P;\\;m=1,2,\\ldots,M\n\\end{array}\n$$\n\nwhere\n\n* $x_{pm}$ is the quantity to be shipped from plant $p$ to market $m$ (decision variable)\n* Objective (a) is to minimize shipping cost\n* Constraint (b) ensures that total supply from a plant is below capacity\n* Constraint (c) ensures that demand for each market is met.\n\n### Model build using OMPR\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nnp = length(plants)\nnm = length(mkts)\n# create ompr model\nmdl = MIPModel() %>%\n  add_variable(x[i, j], i=1:np, j=1:nm, type = \"continuous\",lb = 0) %>%\n  # objective: min cost\n  set_objective(sum_over(cost(i, j) * x[i, j], i = 1:np, j = 1:nm)) %>% \n  # supply from each plant is below capacity\n  add_constraint(sum_over(x[i, j], j = 1:nm) <= cap[i], i = 1:np) %>%  \n  # supply to each market meets demand\n  add_constraint(sum_over(x[i, j], i = 1:np) >= dem[j], j = 1:nm)\n```\n:::\n\n:::\n\nThe figure on the left show the supply network (plants on top and markets below with numbers being capacity for plants and demand for markets). The figure on the right shows the solution where Chicago market is supplied by Seattle plant and San Diego plant supplies both New York and Topeka markets. \n\n:::: {.columns}\n\n::: {.column .border}\n*Network Information*\n![](network_info.png)\n:::\n\n::: {.column .border}\n*Solution*\n![](network_soln.png)\n:::\n::::\n\n### Example 3: Map Coloring Problem\n\nThis example discusses a map coloring problem where the goal is to use the minimum number of colors so that no two adjacent states in the US map have the same color. In this example also, I am just showing the mathematical formulation and OMPR model. The full description of this example is in this [location](https://notesofdabbler.github.io/optwithR/map_colorig_ompr.html). \n\n::: {.panel-tabset}\n### Mathematical Formulation\n\n$$\n\\begin{array}{llr}\n\\min & \\sum_{c=1}^Cy_c & (a)\\\\\n& \\sum_{c=1}^Cx_{ic} = 1, \\;i=1,2,\\ldots,N & (b)\\\\\n& x_{ic} + x_{jc} \\leq y_c, \\; \\mbox{when }i, j \\mbox{ are adjacent} & (c)\\\\\n& x_{ic} \\; binary \\\\\n& y_c \\; binary\n\\end{array}\n$$\n\nwhere:\n\n* $y_c=1$ if color $c$ is used, $x_{ic}=1$ if state $i$ is colored with color $c$.\n* Objective (a) is to minimize the number of colors used\n* Constraint (b) ensures that each state gets some color\n* Constraint (c) ensures that if state $i$ and $j$ are adjacent, they don't get the same color.\n\n### Model build using OMPR\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# OMPR model\nns = nrow(nodes_df)\nnc = 4\nedge_str = edge_df %>% mutate(edge_str = glue(\"{fromid}_{toid}\")) %>% pull(edge_str)\nmdl = MIPModel()\nmdl = mdl %>% add_variable(x[i, c], i = 1:ns, c = 1:nc, type = \"integer\", lb = 0, ub = 1)\nmdl = mdl %>% add_variable(y[c], c = 1:nc, type = \"integer\", lb = 0, ub = 1)\nmdl = mdl %>% set_objective(sum_over(y[c], c=1:nc))\nmdl = mdl %>% add_constraint(sum_over(x[i, c], c = 1:nc) == 1, i = 1:ns)\nmdl = mdl %>% add_constraint(x[i, c] + x[j, c] <= y[c], i = 1:ns, j = 1:ns, c = 1:nc, glue(\"{i}_{j}\") %in% edge_str)\n```\n:::\n\n:::\n\nSolving this problem give the following map coloring\n\n![](USmap_colored.png)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}